S.O.L.I.D принципы - способ регламентировать код таким образом, чтобы он был понятен, удобен для повторного использования, дполнения.
1) Принцип единственной обязанности
У каждого класса должна быть единственная по функциям обязанность. Содержать только те методы, которые реально связанны с объектом.
За классом должна быть очевидно закреплена его обязанность.
2) Принцип открытости/закрытости
Классы должны быть закрыты для модификации, но открыты для расширения. В хорошо спроектированных программах новая функциональность вводится путем добавления нового кода, а не изменения старого. private поля будут участвовать только в логике работы этого самого класса. Данные закрывать, а методы открывать. Хорошим тоном является для каждого поля создавать метод, читающий его и меняющий.
3) Принцип подстановки Барбары Лисков
Разделение регламентации поведения. В любой точки использования объекта в случае подстановки вместо него наследника должно работать корректно, согласно ожиданиям. Наследуйся правильно! Если метод вкладывает в себя "плыть"(уточки), то он должен работать корректно во  всех случаях. (Прямоугольник - квадрат). Решение - добавлять доп методы, выносить общие методы в отдельные интерфейсы. Зависит от контекста требований программы.
4) Принцип разделения интерфейса
То же самое, что в первом принципе, только для интерфейсов. Разделять интерфесы по логике, не создавать один интерфейс, делающий все, и не разделять один смысловой интерфейс на два. Иначе всем наследникам придется реализовывать все методы, указанные в интерфейсе.
5) Принцип инверсии зависимостей
Можно либо жестко связывать две сущности,  либо создавать . Поля являются зависимостью для класса; Например, класс автомобиль зависит от объекта колесо. Зависеть - это не наследование. Можно добавить конструктор, в котором мы присваиваем автомобилю колесо. Не сам автомобиль должен создавать себе объекты зависимостей, а тот, кто снаружи создает объект автомобиля. Прямая зависимость - объект сам заботится о своих зависимостях, а инверсия зависимостей - тот, кто создает объект заботится о них. Если жестко привязываться к одному экземпляру, придется им ограничиваться; если использовать инвертированные зависимости, можно использовать много разных.

Вложенные классы

Имеет смысл, если такой класс будет использоваться только внутри одного класса, в который он вкладывается. Такой класс может быть с любым модификатором доступа. Объект вложенного класса можно создать вне класса, в который он вложен. Для этого нужно создать экземпляр верхнего класса (Car car = new Car();) а потом экземпляр вложенного (Car.Wheel wheel = car.new Car.Wheel;). Как из вложенного класса вызвать приватный метод верхнеуровнего класса?
public void crash() {
	Car.this.crash();
}
(Если просто писать this., то это будет ссылка на вложенный класс)

Внутренние классы

это такой же вложенный класс, отмеченный модификатором static. Этим классом мы начинаем пользоваться как любым другим статическим элементом данного класса. Для создания объекта этого класса не нужен объект внешнего класса. Из объекта вложенного класса нельзя обращаться к не статическим членам внешнего класса. Создание: Car.Wheel wheel = new Car.Wheel();

Локальные классы

Это классы, которые можно создать вообще везде. Похожи на локальные переменные. Правила:
Модификатор доступа не указывается
Невозможно объявление статических методов и иных статических членов, но
Возможно использование констант
Захват внешних локальных переменных возможен, если они определены, как effectively final (это переменные, которые никогда не меняются вне локального класса, константы по смыслу)
Не могут быть статичными

Анонимные классы

Создание объекта интерфейса на лету и передача его в качестве параметра методу. В нем мы переовпределяем run на лету.
public void test(){
	start(new Runnable() {
		public void run(){ }
	});
}
Нет создания отдельного класса, неизвестен тип объекта Runnable(). Заставляет java сделать класс, реализующий объект. Тип неизвестен, поэтому класс анонимный.
Анонимный класс - синтаксический сахар. Это аналог локального класса. Разница только в наличии у класса имени для повторного использования.
public void test(){
	class X implements Runnable{
		public void run(){ }
	};
	start (new X() );
}
То же самое можем делать с любым типом данных, необязательно с интерфесом. Тогда будет ожидаться extends вместо implements. Внутри фигурных скобок можно делать что угодно. 

Исключения

Это конструкция, позволяющая обрабатывать возникающие ошибки. Java предлагает порождать объекты определенных типов данных, которые будут содержать состояние и поведение возникшей ошибки.
Ключевое слово, предваряющее блок кода
try {
Блок кода, который необходимо выполнить
	int x = ...;
	int y = 5 / x;
Если в блоке возникает ошибка, то упарвление будет передано блоку catch, выполнение кода прервется. Таких блоков может быть несколько. 
} catch (ArithmeticException e) {
 // обработка
Блок finally выполняется в любом случае: была ошибка или нет. Он не является обязательным.
} finally {
//обработка
}
Object -> Throwable ->
-> Error (непроверяемое)
-> Excepton (проверяемое) -> 
-> RunTimeException (непроверяемое)
-> Other Exception (проверяемое)
Можно создавать свои классы - исключения. Для этого нужно наследовать его от Exception. Чтобы выбрасывать такое исключение, используется ключевое слово throw. После такого как мы его выбрасываем, новое исключение можно обрабатывать в catch.