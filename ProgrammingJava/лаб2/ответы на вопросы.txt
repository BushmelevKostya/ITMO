1)Объектно-ориентированное программирование. Основные понятия: объекты, наследование, полиморфизм, инкапсуляция.


Объектно-ориентированное программирование (ООП) позволяет разложить проблему на составные части, каждая из которых становится самостоятельным объектом. Каждый из объектов содержит свой собственный код и данные, которые относятся к этому объекту.

Любая программа, написанная на языке ООП, отражает в своих данных состояние физических предметов либо абстрактных понятий – объектов программирования, для работы, с которыми она предназначена.

Все данные об объекте программирования и его связях с другими объектами можно объединить в одну структурированную переменную. В первом приближении ее можно назвать объектом.

С объектом связывается набор действий, иначе называемых методами. С точки зрения языка программирования набор действий или методов – это функции, получающие в качестве обязательного параметра указатель на объект и выполняющие определенные действия с данными объекта программирования. Технология ООП запрещает работать с объектом иначе, чем через методы, таким образом, внутренняя структура объекта скрыта от внешнего пользователя.

Описание множества однотипных объектов называется классом.
Объект – это структурированная переменная, содержащая всю информацию о некотором физическом предмете или реализуемом в программе понятии.

Класс – это описание множества объектов программирования (объектов) и выполняемых над ними действий.

Класс можно сравнить с чертежом, согласно которому создаются объекты. Обычно классы разрабатывают таким образом, чтобы их объекты соответствовали объектам предметной области решаемой задачи.

Основные понятия объектно-ориентированного программирования
Любая функция в программе представляет собой метод для объекта некоторого класса.

Класс должен формироваться в программе естественным образом, как только в ней возникает необходимость описания новых объектов программирования. Каждый новый шаг в разработке алгоритма должен представлять собой разработку нового класса на основе уже существующих.

Вся программа в таком виде представляет собой объект некоторого класса с единственным методом run (выполнить).

Программирование «от класса к классу» включает в себя ряд новых понятий. Основными понятиями ООП являются

инкапсуляция;
наследование;
полиморфизм.
Инкапсуляция данных (от «капсула») – это механизм, который объединяет данные и код, манипулирующий с этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. В ООП код и данные могут быть объединены вместе (в так называемый «черный ящик») при создании объекта.

Внутри объекта код и данные могут быть закрытыми или открытыми.

Закрытые код или данные доступны только для других частей того же самого объекта и, соответственно, недоступны для тех частей программы, которые существуют вне объекта.

Открытые код и данные, напротив, доступны для всех частей программы, в том числе и для других частей того же самого объекта. Они представляют своего рода интерфейс для работы с объектом из других частей программы.

Наследование. Новый, или производный класс может быть определен на основе уже имеющегося, или базового класса.

При этом новый класс сохраняет все свойства старого: данные объекта базового класса включаются в данные объекта производного, а методы базового класса могут быть вызваны для объекта производного класса, причем они будут выполняться над данными включенного в него объекта базового класса.

Иначе говоря, новый класс наследует как данные старого класса, так и методы их обработки.

Если объект наследует свои свойства от одного родителя, то говорят об одиночном наследовании. Если объект наследует данные и методы от нескольких базовых классов, то говорят о множественном наследовании.

Пример наследования – определение структуры, отдельный член которой является ранее определенной структурой.

Наследование структур
Полиморфизм – это свойство, которое позволяет один и тот же идентификатор (одно и то же имя) использовать для решения двух и более схожих, но технически разных задач.

Целью полиморфизма, применительно к ООП, является использование одного имени для задания действий, общих для ряда классов объектов. Такой полиморфизм основывается на возможности включения в данные объекта также и информации о методах их обработки (в виде указателей на функции).

Будучи доступным в некоторой точке программы, объект , даже при отсутствии полной информации о его типе, всегда может корректно вызвать свойственные ему методы.


2) как передавать несколько переменных в метод?


    public Buizel(String name, int ...level){
        super(name, level[0]);
JDK 1.5 и выше позволяет передавать методу переменное количество аргументов одного типа. Параметр в методе объявляется следующим образом:

typeName... parameterName
При объявлении метода Вы указываете тип, за которым следует многоточие (...). В методе может быть указан только один параметр переменной длины, и этот параметр должен быть последним параметром. Любые регулярные параметры должны предшествовать ему.


3) Понятие класса. Классы и объекты в Java.


Класс в Java - это шаблон для создания объекта, а объект - это экземпляр класса. Класс определяет структуру и поведение, которые будут совместно использоваться набором объектов. Класс содержит переменные и методы, которые называются элементами класса, членами класса. Он составляет основу инкапсуляции в Java. Каждый объект данного класса содержит структуру и поведение, которые определены классом. Иногда объекты называют экземплярами класса.

Методы используются для описания того, что объект класса умеет делать или что можно с ним сделать. Переменные - для описания свойств или характеристик объекта.


4) Члены класса. Модификаторы доступа.


Private — наиболее строгий модификатор доступа. Он ограничивает видимость данных и методов пределами одного класса. Они могут спокойно выполнять свою работу внутри класса и не вводить в заблуждение пользователя, которому логика каждого из них по отдельности не нужна.

Дальше у нас по списку идет модификатор default или, как его еще называют, package visible. Он не обозначается ключевым словом, поскольку установлен в Java по умолчанию для всех полей и методов. default = protected - наследование

Поля и методы, обозначенные модификатором доступа protected, будут видны:
в пределах всех классов, находящихся в том же пакете, что и наш;
в пределах всех классов-наследников нашего класса. 

public создан для того, чтобы отдавать что-то пользователям. Например, интерфейс твоей программы. Части кода, помеченные модификатором public, предназначаются для конечного пользователя.


5) Создание и инициализация объектов. Вызов методов.


public static int methodName(int a, int b) {
   // тело
}

public static – модификатор;
int – возвращаемый тип;
methodName – имя метода;
a, b – формальные параметры;
int a, int b – перечень параметров.
Ключевое слово void в Java позволяет нам создать методы, не производящие возврат значения.
Перегрузка методов в Java – случай, когда в классе присутствуют два и более метода с одинаковым именем, но различными параметрами. Данный процесс отличен от переопределения методов. При переопределении методов, метод характеризуется аналогичным именем, типом, числом параметров и т.д.
   // для integer
   public static int minFunction(int n1, int n2) {
      int min;
      if (n1 > n2)
         min = n2;
      else
         min = n1;

      return min; 
   }
   
   // для double
   public static double minFunction(double n1, double n2) {
     double min;
      if (n1 > n2)
         min = n2;
      else
         min = n1;

      return min; 

Конструктор в Java
В Java конструктор инициализирует объект при его создании. Его имя аналогично имени класса, а синтаксис сходен с синтаксисом метода. Однако, в отличие от последнего, в конструкторе отсутствует возвращаемое значение.

Как правило, конструктор в Java может использоваться для присвоения исходного значения переменных экземпляра, определяемых классом, либо для выполнения каких-либо иных процедур запуска, необходимых для создания полностью сформированного объекта.

Конструкторы присутствуют во всех классах, независимо от их указания, в виду того, что Java автоматически предоставляет конструктор по умолчанию, который инициализирует все переменные членов класса до нуля. Вместе с этим, после того как вы определите собственный конструктор, конструктор по умолчанию больше не будет задействован.

Ключевое слово this – используется для ссылки на текущий класс с учетом метода или конструктора экземпляра. Используя this в Java, Вы можете ссылаться на экземпляры класса, такие как конструкторы, переменные и методы.

Примечание: ключевое слово this используется только в составе методов либо конструкторов экземпляра.

Как правило, ключевое слово this в Java используется для:

дифференцирования между переменными экземпляра и локальными переменными в случае, если у них одинаковые имена, в составе конструктора или метода.
class Student {
   int age;   
   Student(int age) {
      this.age = age;	
   }
}
вызова конструктора одного типа (параметризованного конструктора либо конструктора по умолчанию) из другого в составе класса. Данный процесс также носит название явного вызова конструктора.
class Student {
   int age
   Student() {
      this(20);
   }
   
   Student(int age) {
      this.age = age;	
   }
}
Метод finalize() – метод, который будет вызываться непосредственно перед окончательным уничтожением объекта сборщиком мусора. (финализатором). В Java finalize() может быть использован для обеспечения чистого завершения объекта.

К примеру, мы можете использовать finalize() чтобы удостовериться в том, что открытый файл, принадлежащий данному объекту, был закрыт.

Во-первых, задаётся переменная класса Cat под именем murka. Эта переменная ещё не определяет объект, она просто даёт возможность ссылаться на него.
Во-вторых, создаётся физическая копия объекта, а ссылка на него присваивается переменной murka. Это делается с помощью оператора new. Оператор new динамически — во время выполнения программы — выделяет память для объекта и возвращает ссылку на него, которая представляет собой адрес области памяти.
В-третьих, ссылка на объект сохраняется в переменной. За это отвечает оператор =.


6) Области видимости переменных.


Область видимости переменных или просто “Область видимости” (англ. variable scope или просто scope) — это такая область программы, в пределах которой установлена связь между некоторой переменной и её идентификатором (именем), по которому можно получить значение этой переменной. 
Область видимости аргументов метода — тело метода
Внутри класса область видимости зависит от типа переменной:

Статические переменные принадлежат самому классу. Они доступны без создания объекта, область их видимости содержит все методы класса — как статические, так и нет.
Нестатические переменные класса принадлежат экземпляру класса (объекта). В их область видимости попадают нестатические методы класса.
По умолчанию используется переменная с более узкой областью видимости, то есть аргумент метода. Чтобы использовать переменную класса, необходимо на неё явно указать с помощью ключевого слова this.


7) Модификаторы final и static.


final — это модификатор, позволяющий объявлять константные поля в классе. Если у вас есть некоторое свойство проектируемого вами объекта, значение которого не будет меняться, то вы можете воспользоваться этим модификатором. Любая попытка переопределить значение поля с модификатором final приводит к выбросу исключения.
Static поле: существует на уровне класса, а не объекта; Для каждого класса создается только один экземпляр статической переменной (переменой класса).
При описании статических переменных должны быть выполнены следующие правила:
статические переменные должны быть объявлены вне всякого метода;
статические переменные могут быть инициализированы при их объявлении или блоком кода, отмеченного ключевым словом static, и также расположенным вне метода.
static модификатор перед методом или полем говорит о том, что они не принадлежат к экземпляру данного класса. Что это означает для нас? Когда мы описали поле класса или метод как static, его можно вызвать без использования экземпляра класса. То есть вместо такой конструкции: Cat cat = new Cat(); cat.method(), можно написать просто Cat.method(). При условии, что метод объявлен как static. Статические переменные едины для всех объектов класса. У них одна ссылка.
Думаю, слово final говорит само за себя. Применяя final модификатор Вы говорите, что поля не могут быть изменены, методы переопределены, а классы нельзя наследовать (о наследовании будет отдельная статья). Этот модификатор применяется только к классам, методам и переменным (также и к локальным переменным).
Класс, который имеет модификатор abstract не может создать экземпляр. Единственная цель для него быть расширенным. Класс abstract может содержать как абстрактные методы, а также и обычные.


8) Пакеты, инструкция import.


Следовательно, чтобы отдельные классы или весь пакет можно было сделать доступными, в Java внедрен оператор import.

После того как класс импортиро­ван, на него можно ссылаться непосредственно, используя только его имя.
И наконец, имя_класса может быть задано явно или с помощью знака "звездочка" (*) который указывает компилятору Java на необходимость импорта всего пакета.
Запомните, что при импорте пакета классам, не производным от классов из данного пакета в импортирующем коде, будут доступны только те элементы пакета, которые объявлены как public.
Чтобы улучшить читабельность кода можно импортировать статические члены класса почти так же, как и обычные классы, и получить прямой доступ к статическим членам без указания имени класса
import static java.lang.Math.PI;
import static java.lang.Math.cos;


9) enum


   private DayOfWeek(String title) {
       this.title = title;
   }

   public static DayOfWeek SUNDAY = new DayOfWeek("Воскресенье");
   public static DayOfWeek MONDAY = new DayOfWeek("Понедельник");
   public static DayOfWeek TUESDAY = new DayOfWeek("Вторник");
   public static DayOfWeek WEDNESDAY = new DayOfWeek("Среда");
   public static DayOfWeek THURSDAY = new DayOfWeek("Четверг");
   public static DayOfWeek FRIDAY = new DayOfWeek("Пятница");
   public static DayOfWeek SATURDAY = new DayOfWeek("Суббота");
Приватный конструктор. Если конструктор помечен модификатором private, объект класса нельзя создать с помощью этого конструктора. А поскольку в этом классе конструктор всего один, объект DayOfWeek нельзя создать вообще.
При этом в классе содержалось нужное количество public static объектов, которые были инициализированы нужным нам образом (названия дней правильные).
Это позволяло использовать объекты в других классах.
public enum DayOfWeek {

   SUNDAY,
   MONDAY,
   TUESDAY,
   WEDNESDAY,
   THURSDAY,
   FRIDAY,
   SATURDAY
}
Внутри нашего Enum находятся 7 констант со статическим доступом. Мы уже можем его использовать для реализации логики в программе.
Enum: его константы можно использовать с оператором switch.
public class VeryStrictDiet {
   public void takeLunch(DayOfWeek dayOfWeek) {
       switch (dayOfWeek) {
           case SUNDAY:
               System.out.println("Воскресный обед! Сегодня можно даже немного сладкого");
               break;
           case MONDAY:
               System.out.println("Обед для понедельника: куриная лапша!");
               break;
           case TUESDAY:
               System.out.println("Вторник, сегодня суп из сельдерея :(");
               break;
               //...и так далее до конца
       }
   }
}
если текущей реализации дней недели тебе недостаточно, ты можешь добавить в DayOfWeek переменные, конструкторы и методы
По сравнению с обычными классами, на Enum наложили одно серьезное ограничение — от него невозможно наследоваться.
values(): возвращает массив из всех хранящихся в Enum значений
ordinal(): возвращает порядковый номер константы. Отсчет начинается с нуля
valueOf(): возвращает объект Enum, соответствующий переданному имени

10) приватный конструктор


Конструкторы могут иметь модификатор доступа private
Мы можем сделать конструктор приватным (private), что не позволит создавать его экземпляры. Какой в этом смысл? Например, в паттерне проектирования Одиночка (Singleton) приватный конструктор используется для контроля над количеством создаваемых экземпляров. Всегда можно будет создать только один объект.


11) Множественное наследование java


Это приводит к неоднозначности, поскольку компилятор не знает, какой метод суперкласса выполнять. Это есть диаграмма классов ромбовидной формы, которая называется  ромбовидная проблема. Это есть главная причина, по которой в Java не поддерживается множественное наследование.


стадические динамические полиморфизмы
переопределение
три парадигмы
перегрузка
